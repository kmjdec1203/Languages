# C++_7

## 그냥 수업내용

일반변수 : 생성자나 소멸자가 어떻든 상관이 없다.

참조형 변수 :  

& 하나면 l-value 참조. 상수가 안 된다.



---

## 퀴즈



클래스의 접근 제어 지시자 중에서 private가 의미하는 것은?

클래스에서 외부의 접근이 불가능하다.

파생클래스로부터의 접근이 불가능하다.

별도로 접근제어지시자를 기술하지 않았을 때 private으로 된다. (디폴트 값)



인스턴스가 생성될 때 자동으로 호출되는 함수 => 생성자

생성자는 클래스랑 함수 이름이 같다. 반환 자료형이 없다.

클래스 : 생성자 초기화 목록



멤버가 참조일 때 대입 연산 안 된다. 생성자 초기화 목록으로 해야된다.



메서드 함수 내부에서 실제 클래스 인스턴스의 주소를 가리키는 포인터 => this



상수형 메서드에서 할 수 없는 일 => 멤버변수 수정이 불가능하다. 읽기만 가능하고 쓰기는 불가능하다. 



정적 멤버에서는 this를 사용할 수 없다. (전역이기 때문)



디폴트 생성자는 매개변수가 없다.

CTest() {

다중	()
			()

}

복사생성자.

형태 : 클래스이름(const 클래스 이름 &rhs); 복사생성자 함수에는 매개변수로 상수형 객체 참조형이 넘어감. 



단순히 멤버 대 멤버로 저장되어 있는 값을 복사하는 것을 Shallow copy라고 한다.

포인터일 경우 주소가 넘어가기 때문에 문제가 발생할 수 있다.



CTest a(10); 

CTest b(a);	// 명시적으로 객체의 복사본을 생성하는 방식



매개변수에 클래스가 있을 경우 복사생성자가 호출됨.

반환하는 곳에 있을 때도 마찬가지.



복사를 막는 방법

1. 복사 생성자를 삭제. (아예 복사생성자를 CTestData(const CTestData& rhs) = delete 이렇게 생성한다.)
2. 함수에 객체를 넘기지 않고 함수에 객체 참조를 넘긴다. 참조를 넘기면 객체 복사가 일어나지 않음.



복사 생성자 (포인터가 없을 때)

```c++
#include	<iostream>
using	namespace	std;
class	CMyData {
public:
	CMyData() { cout << "CMyData()" << endl; }
	int	GetData()	const { return		m_nData; }
	void	SetData(int	nParam) { m_nData = nParam; }
private:
	int	m_nData = 0;
};
int	main()
{
	//	디폴트	생성자가	호출되는	경우
	CMyData	a;
	a.SetData(10);
	//	복사생성자가	호출되는	경우
	CMyData	b(a);
	cout << b.GetData() << endl;
	return	0;
}
```