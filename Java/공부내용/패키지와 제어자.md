# 04: 패키지와 제어자

## 패키지(package)

패키지는 자바 `클래스들을 구분` 하기 위해 사용합니다. 객체지향 프로그래밍에서는 여러 클래스들이 사용되고 내가 직접 만들지 않은 클래스 혹은 라이브러리들을 사용하는 경우도 많이 있다. 이 때 클래스들의 이름이 모두 동일하다면 문제가 발생할 수 있다.

예를 들어 회원 관리 프로그램에 Login 클래스가 있을 수 있으며 카페나 블로그, 쇼핑물 쪽에서도 Login 클래스가 있을 수 있습니다. 이처럼 서로 다른 목적에서 개발된 클래스들을 서로 구분하기 위해 패키지를 사용하게 된다.

그리고 이러한 패키지들을 전세계적으로 문제 없이 관리하기 위한 일종의 규약이 존재하는데 패키지 이름의 관리를 `역도메인(reverse domain)` 방식으로 하는 것입니다.

도메인은 인터넷에서 기관을 이름으로 구분한 것인데 패키지는 이를 뒤집어서 사용하게 된다.

예들 들어 네이버의 도메인은 `naver.com` 인데 만일 네이버 개발자들이 자바 클래스를 개발하게 된다면 `com.naver` 를 루트 패키지명으로 사용하게 되는 것이다. 실제 네이버는 카페, 블로그, 메일 등과 같은 서비스를 운영하고 있기 때문에 이들에 사용되는 클래스들은 각각 `com.naver.cafe`, `com.naver.blog`, `com.naver.mail` 과 같은 패키지명을 사용하게 되는 것이다.

이와 같은 규칙 때문에 체계적으로 클래스들을 관리할 수 있고 또 서로 다른 기관에서 만든 클래스들도 혼선 없이 사용할 수 있는 것이다.

처음 자바를 시작하는 경우 학습의 목적이므로 별도의 패키지를 만들지 않는 경우가 많으나 가급적 패키지명을 사용하는 습관을 들이는 것이 좋다.

### `package 선언`

클래스에 패키지를 선언하는 것은 `package` 키워드를 이용해 소스 상단에 패키지 이름을 넣어주는 것이다.

```java
package com.my.study;

class MyClass {

}
```

### `package import`

현재 구현중인 클래스에서 동일 패키지에 있는 클래스가 아닌 `다른 클래스(외부 라이브러리 등` 를 사용하는 경우 반드시 `import` 문을 사용해 해당 클래스의 패키지를 명시해주어야 한다. 만일 `import` 문을 사용하지 않는다면 소스코드에서 해당 클래스 사용 시 매번 클래스 앞에 패키지명까지 붙여주어야 한다.

```java
class MyClass {
 java.util.Scanner scan = new java.util.Scanner(System.in);   
}
```

대부분의 경우 매번 패키지명을 붙여주는 방식보다는 해당 클래스의 패키지를 import 해주는 방법을 사용한다.

```java
import java.util.Scanner;

class MyClass {
    Scanner scan = new Scanner(System.in);
}
```

원칙적으로는 사용되는 모든 클래스를 import 해주는 것이며 특정 패키지의 모든 클래스를 한번에 import 하기 위해서는 다음과 같이 `*`을 사용하기도 한다.

```java
import java.util.*;
```

그러나 이러한 방식은 많은`라이브러리를 동시에 사용` 하는 경우 클래스 이름 중복으로 인한 문제가 발생할 수 있으므로 주의해야 한다. 보통은 개발도구에서 자동으로 패키지 `import` 를 관리하므로 신경쓰지 말고 개별 클래스들이 `import` 될 수 있도록 하는 것이 좋다.

실제 패키지는 디스크 상에는 `디렉토리 개념` 으로 소스 폴더를 열어보면 com 폴더 아래 my 폴더가 있고 그 아래 study 폴더에 자바 소스 파일드이 위치한 것을 확인할 수 있다.

## 제어자(Modifier)

제어자는 클래스, 변수, 메서드의 선언부에 사용되어 `부가적인 의미를 부여`한다. 이미 여러 코드에서 나온 `public, static` 같은 키워드들이 여기에 해당된다. 이러한 제어자에는 클래스의 접근 범위와 관련된 `접근 제어자(access modifier`와 일반 제어자가 있다.

*  접근 제어자 : public, private, protected, default
* 일반 제어자 : static, final, abstract, native, transient, synchronized, volatile, strictfp

이들 제어자는 상황에 따라 클래스, 메서드, 변수 등에 사용하며 하나의 대상에 여러개의 제어자를 조합해서 사용할 수 있으나, `접근 제어자는 단 하나만 사용`할 수 있다.

### `static`

`클래스 혹은 공통적인` 이라는 의미를 가지고 있으며 앞에서 배운 클래스 변수나 메서드의 선언에 사용할 수 있다. static의 특징은 다음과 같다.

* 멤버변수와 메서드, 초기화 블럭은 인스턴스를 생성하지 않고도 사용할 수 있다.
* 모든 인스턴스에 공통적으로 사용되는 클래스 변수
* 클래스 변수는 인스턴스를 생서아지 않고도 사용 가능
* 클래스가 메모리에 로드될 때 생성
* 인스턴스 생성 없이 클래스 이름 메서드명() 으로 사용 가능한 static 메서드 선언

### `final`

변경할 수 없다는 의미를 가지고 있으며 변수나 메서드, 클래스에 사용할 수 있다.

* 메서드에 사용할 경우 오버라이딩을 통해 재정의할 수 없음
* 변수에 사요할 경우 실수가 됨
* 클래스에 사용할 경우 더 이상 상속을 할 수 없는 클래스가 됨

### `abstract`

앞에서 살펴본 추상 클래스와 추상 메서드를 선언할 때 사용한다.

* 메서드의 선언부만 작성하고 실제 수행 내용은 구현하지 않은 추상 메서드를 선언하는 데 사용
* 추상 메서드가 있는 클래스는 반드시 추상 클래스로 선언 되어야 함

### 접근 제어자(access modifier)

접근 제어자는 `멤버 또는 클래스에 사용`하며 외부에서의 접근을 제어하기 위해 사용한다. 예를 들어 내가 만드는 패키지의 클래스들 중 일부는 외부에서 사용할 수 있도록 하고 일부 클래스는 내가 만든 클래스에서만 사용할 수 있도록 하는 등의 제어가 가능하다.

지정되어 있지 않다면 default가 된다.

* public : 접근 제한이 없음
* protected : 같은 패키지 내에서 혹은 다른 패키지의 자손 클래스에서 접근이 가능
* default : 같은 패키지 내에서만 접근이 가능
* private : 같은 클래스 내에서만 접근이 가능

유형별로는 다음과 같은 접근 제어자 사용이 가능하다.

* 클래스 : public, default
* 메서드, 멤버변수 : public, protected, default, private
* 지역변수 : 지역변수 자체가 해당 블럭에서만 사용 가능하므로 접근 제어자의 의미가 없음

일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치하며 생성자에 접근 제어자를 사용하는 경우 인스턴스의 생성을 제한할 수 있다, 이는 소프트웨어 디자인 패턴에서 단일 인스턴스를 보장하는 `싱글턴 패턴(singleton Pattern)`의 구현에 활용되기도 한다.

### `캡슐화와 접근 제어자`

캡슐화는 객체지향 프로그램의 대표적인 특징중 하나이다. 접근 제어자를 사용하면 클래스 외부로부터의 접근을 제어할 수 있으므로 객체를 캡슐화할 수 있다.

예를 들어 private의 경우 동일 클래스 내에서만 접근이 가능하므로 멤버필드에 private를 선언하면 해당 변수를 클래스 외부에서 접근할 수 없게 된다.

이 경우 클래스 외부에 해당 멤버의 접근을 제공하기 위해 getter, setter 메서드를 제공하는 방식을 사용하게 된다. getter 는 멤버값을 제공하기 위해 setter는 멤버값의 변경을 위해 사용한다.

메서드 생성 규칙은 `멤버타입 getXxx()`, `setXxx(멤버타입 인자)` 형식이다.

```java
private int count;

public int getCount() {
    return count;
}

public void setCount(int count) {
    this.count = count;
}
```

보통 위와 같은 형식을 취하며 단순히 값을 넘겨주거나 설정하기도 하고 원하는대로 데이터를 조작하거나 처리 기능을 구현하면 된다.